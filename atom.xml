<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Coding Notes]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://gabriel0402.github.io/"/>
  <updated>2015-12-27T04:08:14.000Z</updated>
  <id>http://gabriel0402.github.io/</id>
  
  <author>
    <name><![CDATA[G]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Angular2 依赖注入]]></title>
    <link href="http://gabriel0402.github.io/2015/12/25/angular-dependency-injection/"/>
    <id>http://gabriel0402.github.io/2015/12/25/angular-dependency-injection/</id>
    <published>2015-12-26T04:44:16.000Z</published>
    <updated>2015-12-27T04:08:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这是Angular2教程的第三部分，主要介绍Angular2的service的使用，以及ood在angular2里面的实现方式。相关博客如下：</p>
<ol>
<li><a href="http://gabriel0402.github.io/2015/12/21/overview/">Angular2 初探</a></li>
<li><a href="http://gabriel0402.github.io/2015/12/24/angular2-form/">Angular2 表单验证</a></li>
<li>Angular2之rxjs以及http的世界</li>
<li>Angular2 cheatsheet</li>
</ol>
<a id="more"></a>
<h2 id="参考资料">参考资料</h2><p>还是小G上个博客里面介绍的例子，链接在这：<a href="https://github.com/Gabriel0402/angular2_beta_test" target="_blank" rel="external">Angular 2 quick start</a>。文件结构如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├──angular2/                                    </span><br><span class="line">│   │</span><br><span class="line">│   ├──app/                               </span><br><span class="line">│   │   ├──boot<span class="class">.ts</span>                          </span><br><span class="line">│   │   ├──app<span class="class">.component</span><span class="class">.ts</span>   </span><br><span class="line">│   │   ├──hero-list/             <span class="comment">//依赖注入 用</span></span><br><span class="line">│   │       ├──edit-item<span class="class">.ts</span></span><br><span class="line">│   │       ├──hero-card<span class="class">.component</span><span class="class">.ts</span></span><br><span class="line">│   │       ├──hero-editor<span class="class">.component</span><span class="class">.ts</span></span><br><span class="line">│   │       ├──hero<span class="class">.ts</span></span><br><span class="line">│   │       ├──heros-list<span class="class">.component</span><span class="class">.ts</span></span><br><span class="line">│   │       ├──heroes<span class="class">.service</span><span class="class">.ts</span></span><br><span class="line">│   │       ├──restore<span class="class">.service</span><span class="class">.ts</span></span><br><span class="line">│   ├──index<span class="class">.html</span></span><br><span class="line">│   ├──package<span class="class">.json</span>   <span class="comment">//用来安装我们需要的库， 以及node的一些命令</span></span><br><span class="line">│   ├──tsconfig<span class="class">.json</span>  <span class="comment">//用来配置typescript</span></span><br><span class="line">│   ├──style<span class="class">.css</span>      <span class="comment">//这个playground的css</span></span><br></pre></td></tr></table></figure></p>
<p>在这篇博客里主要会用到的是hero-list这个模块，这个模块的主要作用做一个可更改的英雄名称，并且带有保存和取消的功能。保存需要保存当前的更改，而取消则需要恢复更改之前的名字，当已经更改了英雄的名称但是取消了之后这个会返回到更改之前的结果。</p>
<h2 id="依赖注入介绍">依赖注入介绍</h2><p>在OOD中，一般一个class要初始化的时候，construct里面会有这个class需要依赖的class，比如我们要造一辆车，我们需要引擎和轮胎。我们可以这么做：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Car&#123;</span><br><span class="line">    <span class="keyword">private</span> engine:Engine;</span><br><span class="line">    <span class="keyword">private</span> tires:Tires;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>()</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = <span class="keyword">new</span> Engine();</span><br><span class="line">        <span class="keyword">this</span>.tires=<span class="keyword">new</span> Tires();</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是这并不是一个好的ood的方法，因为一辆车有很多的引擎，有不同的轮胎，每次我们要初始化不同引擎不同轮胎的车我们都要改constructor去使用不同的引擎不同的轮胎。所以这种设计没有可扩展性。所以我们可以一般的OOD的方法是把这个class需要的东西放入constructor的参数中，如<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Car&#123;</span><br><span class="line">    <span class="keyword">private</span> engine:Engine;</span><br><span class="line">    <span class="keyword">private</span> tires:Tires;</span><br><span class="line">    <span class="constructor"><span class="keyword">constructor</span>(engine: Engine, tires: Tires) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.engine = engine;</span><br><span class="line">        <span class="keyword">this</span>.tires = tires;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们初始化对象的时候，可以这么做:<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="keyword">new</span> Engine(), <span class="keyword">new</span> Tires());</span><br></pre></td></tr></table></figure></p>
<p>这样车的类就基于引擎的类以及轮胎的类，而这也有很好的扩展性，当我们想建造不同的车的时候，我们可以使用不同的引擎以及不同的轮胎，只有在初始化对象的时候需要明确引擎以及轮胎的类就行。在Angular2里面引用了同样地思路。在第一篇博客中提到directive和providers的概念，其中directive是用来包括子模块，但是父模块一般不会使用子模块的逻辑或者方法，子模块对于父模块来说相当于一个有输入输出接口的黑盒，它只给它的父模块一个名字(定义在子模块的selector里)，然后父模块在模板里面引用子模块，并且给予输入输出。然而如果两个模块想共享某些逻辑的时候该如何呢？这时候就用到service的概念了。service就好象c++里面的接口一样，使得不同的模块之间能够通信。但我们需要给让一个模块使用service的时候，有两种方法:</p>
<ol>
<li>在bootstrap函数里面加入根模块，然后加上service component。如:<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootstrap<span class="list">(<span class="keyword">AppComponent</span>, [HeroService])</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这样就把这个service加入到整个app里面。然后这个app component包括它所有的子模块都能使用 HeroService这个service。<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     A</span><br><span class="line">     |</span><br><span class="line">B----<span class="keyword">C</span>---<span class="keyword">D</span></span><br><span class="line">|</span><br><span class="line"><span class="keyword">E</span></span><br></pre></td></tr></table></figure></p>
<p>比如上图这个结构，A是根模块，然后有BCD三个子模块，然后B还有E这个子模块。ABCDE都能使用用bootstrap函数加入的service。但有一点要注意的是，在Angular2里面所有的service是单例的。单例在OOD里面的意思是整个app只能有一个对象，在Angular2里面同样是这个意思，如果把service加在根模块，虽然所有的子模块都共享这个service，但是它产生的service是单例的，只有一个子模块在runtime能使用这个service。这样就会产生一个问题，比如我有一个保存的service用来保存当前值，然后BCD这三个模块都需要保存的功能，但是由于service是单例的，它只能保存一个值，这样就会产生问题。解决办法就是模块使用service的第二种方法:</p>
<ol>
<li>在component的providers里面直接加入service，如:<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span>(&#123;</span><br><span class="line">  <span class="attribute">selector</span>: <span class="string">'hero-editor'</span>,</span><br><span class="line">  <span class="attribute">providers</span>: [RestoreService]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>然后在类的constructor里面加入这个service:<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(<span class="keyword">private</span> restoreService: RestoreService&lt;Hero&gt;)</span> <span class="comment">&#123;&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样之后虽然每个service是单例的，但是由于每个模块有自己的service，所以这个service互相不干扰，每个模块可以有自己的保存功能。在类里面可以用this.restoreService来使用这个service的实例。<br>而我们在写service的时候，一般没有@Component了，只有一些函数,以及实现逻辑。一般可以做成service的可以是模块之间的信息交流，也可以是模块对外拿data，也可以是一个可扩展可共享的函数逻辑，比如我们要做还原功能，我们可以有一个restore service:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RestoreService</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  originalItem: T;</span><br><span class="line">  currentItem: T;</span><br><span class="line"></span><br><span class="line">  setItem (item: T) &#123;</span><br><span class="line">    <span class="keyword">this</span>.originalItem = item;</span><br><span class="line">    <span class="keyword">this</span>.currentItem = <span class="keyword">this</span>.clone(item);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getItem () :T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.currentItem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  restoreItem () :T &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentItem = <span class="keyword">this</span>.originalItem;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getItem();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clone (item: T) :T &#123;</span><br><span class="line">    <span class="comment">// super poor clone implementation</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(item));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为每个模块都需要这个service，所以需要用providers来吧service引入到component里面。<br>但如果一个service要用另外一个service应该怎么做呢？由于service是一个类，所以我们并不需要引入providers，我们只需要import相应的子service然后在父service的constructor中加入这个Service，比如如果我们想要在restore service里面加入一个logger service，我们只需要:<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Logger&#125; from <span class="string">'./logger'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Injectable&#125; from <span class="string">'angular2/angular2'</span>;</span><br><span class="line"></span><br><span class="line">@Injectable()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> RestoreService&lt;T&gt; &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(private logger: Logger) </span>&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  restoreItem () :T &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentItem = <span class="keyword">this</span>.originalItem;</span><br><span class="line">    <span class="keyword">this</span>.logger.log(<span class="string">'this is restore item'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getItem();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一点要注意是 @Injectable() 这个语法。这个不是可省略的。一定要加入这个@Injectable()，一定要加入这个@Injectable()，一定要加入这个@Injectable()。重要的事情说三遍。因为Angular2需要这个语法来把logger插入到restore service里面，如果没有这个@Injectable(), Angular2就不知道要插入这个Logger service，<br>就会报错。大家可能会有疑问，那为啥在component里面加入restore service的时候不需要加入@Injectable呢？这是因为component已经用@Component表示了，所以在这里可以省略。<br>在依赖注入里面，还有一点是service的provider可以是类，可以是值，也可以是工厂类型。<br>service的provider是类的例子上面已经给出了，如果provider是值的例子如下:<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">beforeEachProviders(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  let emptyHeroService = &#123; <span class="attribute">getHeroes</span>: <span class="function"><span class="params">()</span> =&gt;</span> [] &#125;;</span><br><span class="line">  <span class="keyword">return</span> [ provide(HeroService, &#123;<span class="attribute">useValue</span>: emptyHeroService&#125;) ];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个一般用于Jasmine测试里。<br>如果provider是一个工厂类型，这更符合扩展性的要求。比如我们有A service，依赖于B service，但我们同时在C service某个参数为真时使用这个service，我们就可以这么写:<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let AServiceFactory = <span class="function"><span class="params">(b: B, c: C)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HeroService(b, c.isSpecial);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，只有c.isSpecial 是真的时候我们才使用C的service。<br>如果我们要用工厂类型的时候，可以定义一个definition:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let ADefinition = &#123;</span><br><span class="line">   useFactory: AServiceFactory,</span><br><span class="line">   deps: [B, C]</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">let AServiceProvider = provide(<span class="keyword">A</span>, ADefinition)<span class="comment">;</span></span><br><span class="line">bootstrap(AppComponent, [AServiceProvider, B, C])<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="具体实例">具体实例</h2><p>在hero-list这个例子中，有两个service，一个是heros.service，用来保存现有的英雄名字以及超能力。如果要扩展可以用restful api来得到英雄的名字以及超能力。另外一个是restore.service,用于保存更改之前的结果，如果按取消就返回保存之前的结果。<br>还有一个hero的类，由于是简单版本，所以只有名字和超能力的元素。<br>接下来是hero-editor.component以及hero-card.component，这两个模块是hero-list.component这个模块的两个子模块，在hero-list.component里面对于每个从heroes.service里面得到的英雄，都包含hero-editor.component来编辑英雄的名字以及hero-card.component<br>来显示更改之后的内容。<br>在hero-list.component里可以看到:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attribute">li</span> *<span class="attribute">ngFor</span>=<span class="value">"#editItem of heroes"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt; <span class="attribute">hero-card</span></span><br><span class="line">            [<span class="attribute">hidden</span>]=<span class="value">"editItem.editing"</span></span><br><span class="line">            [<span class="attribute">hero</span>]=<span class="value">"editItem.item"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt; /<span class="attribute">hero-card</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt; <span class="attribute">button</span></span><br><span class="line">            [<span class="attribute">hidden</span>]=<span class="value">"editItem.editing"</span></span><br><span class="line">            (<span class="attribute">click</span>)=<span class="value">"editItem.editing = true"</span>&gt;</span></span><br><span class="line">              edit</span><br><span class="line">          <span class="tag">&lt; /<span class="attribute">button</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt; <span class="attribute">hero-editor</span></span><br><span class="line">            (<span class="attribute">saved</span>)=<span class="value">"onSaved(editItem, $event)"</span></span><br><span class="line">            (<span class="attribute">canceled</span>)=<span class="value">"onCanceled(editItem)"</span></span><br><span class="line">            [<span class="attribute">hidden</span>]=<span class="value">"!editItem.editing"</span></span><br><span class="line">            [<span class="attribute">hero</span>]=<span class="value">"editItem.item"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt; /<span class="attribute">hero-editor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; /<span class="attribute">li</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于hero-editor这个component，它定义了(saved)和(canceled)这两个@Output，在按按键的时候发出这个事件，并且用restore service来更改内容，然后hero-list.component监听到这个事件，做除相应的保存或者返回操作。在这里要注意一点的是，在第一章博客我提到了用output传递参数，<br>在这里我们可以看到在保存的时候，在hero-editor.component里:<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onSaved () &#123;</span><br><span class="line">   <span class="keyword">this</span>.saved.<span class="keyword">next</span>(<span class="keyword">this</span>.restoreService.getItem());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它把这个当前的值传递了出去，而在hero-list.component监听的时候，<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attribute">hero-editor</span></span><br><span class="line">    (<span class="attribute">saved</span>)=<span class="value">"onSaved(editItem, $event)"</span></span><br><span class="line">    (<span class="attribute">canceled</span>)=<span class="value">"onCanceled(editItem)"</span></span><br><span class="line">    [<span class="attribute">hidden</span>]=<span class="value">"!editItem.editing"</span></span><br><span class="line">    [<span class="attribute">hero</span>]=<span class="value">"editItem.item"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt; /<span class="attribute">hero-editor</span>&gt;</span></span><br><span class="line"></span><br><span class="line">onSaved (editItem: EditItem<span class="tag">&lt;<span class="title">Hero</span>&gt;</span>, updatedHero: Hero) &#123;</span><br><span class="line">    editItem.item = updatedHero;</span><br><span class="line">    editItem.editing = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数通过event传递了过来，并且可以直接使用。在这里type就是传递时候的type。<br>再这个例子里，只有hero-editor基于restore的service，所以只有hero-editor加入了restore的service。由于有多个hero-editor，所以多个service会有多个实例。而heroes-service只需要在主模块里面使用，所以他是一个单例模式。</p>
<h2 id="小结">小结</h2><p>这一个博客主要介绍了一下依赖注入，主要有下面几个知识点:</p>
<ol>
<li>在模块中加入service有两种方法，但由于service是单例模式的，所以不同的方法会有不同的行为，总体来说如果在app里面只需要一个实例存在可以把service加载根模块中，但如果每个模块都需要这个service则需要使用providers来插入service。</li>
<li>service的provider可以不仅仅是类，也可是值或者是工厂。</li>
<li>如果在service里面加入service需要@Injectable。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>这是Angular2教程的第三部分，主要介绍Angular2的service的使用，以及ood在angular2里面的实现方式。相关博客如下：</p>
<ol>
<li><a href="http://gabriel0402.github.io/2015/12/21/overview/">Angular2 初探</a></li>
<li><a href="http://gabriel0402.github.io/2015/12/24/angular2-form/">Angular2 表单验证</a></li>
<li>Angular2之rxjs以及http的世界</li>
<li>Angular2 cheatsheet</li>
</ol>]]>
    
    </summary>
    
      <category term="Angular2" scheme="http://gabriel0402.github.io/tags/Angular2/"/>
    
      <category term="Angular2 教程" scheme="http://gabriel0402.github.io/tags/Angular2-%E6%95%99%E7%A8%8B/"/>
    
      <category term="依赖注入" scheme="http://gabriel0402.github.io/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Angular2" scheme="http://gabriel0402.github.io/categories/Angular2/"/>
    
      <category term="依赖注入" scheme="http://gabriel0402.github.io/categories/Angular2/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="Angular2 教程" scheme="http://gabriel0402.github.io/categories/Angular2/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/Angular2-%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angular2 表单验证]]></title>
    <link href="http://gabriel0402.github.io/2015/12/24/angular2-form/"/>
    <id>http://gabriel0402.github.io/2015/12/24/angular2-form/</id>
    <published>2015-12-25T05:19:33.000Z</published>
    <updated>2015-12-26T06:39:10.000Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>这是Angular2教程的第二部分，主要介绍Angular2的form的使用。相关博客如下：</p>
<ol>
<li><a href="http://gabriel0402.github.io/2015/12/21/overview/">Angular2 初探</a></li>
<li>Angular2 dependency injection</li>
<li>Angular2之rxjs以及http的世界</li>
<li>Angular2 cheatsheet</li>
</ol>
<a id="more"></a>
<h2 id="参考资料">参考资料</h2><p>还是小G上个博客里面介绍的例子，链接在这：<a href="https://github.com/Gabriel0402/angular2_beta_test" target="_blank" rel="external">Angular 2 quick start</a>。文件结构如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├──angular2/                                    </span><br><span class="line">│   │</span><br><span class="line">│   ├──<span class="keyword">app</span>/                               </span><br><span class="line">│   │   ├──<span class="keyword">boot</span>.ts                          </span><br><span class="line">│   │   ├──<span class="keyword">app</span>.component.ts   </span><br><span class="line">│   │   ├──hero/                  <span class="comment">//这篇博客用   </span></span><br><span class="line">│   │   |   |──hero.component.ts</span><br><span class="line">│   │   ├──hero-<span class="keyword">form</span>/             <span class="comment">//form blog 用</span></span><br><span class="line">│   │   |   ├──hero.ts                         </span><br><span class="line">│   │   |   |──hero-<span class="keyword">form</span>.component.ts</span><br><span class="line">│   │   |   |──hero-<span class="keyword">form</span>.component.html</span><br><span class="line">│   │   ├──hero-<span class="keyword">list</span>/             <span class="comment">//dependency injection 用</span></span><br><span class="line">│   │   |   ├──...</span><br><span class="line">│   ├──index.html</span><br><span class="line">│   ├──package.json   <span class="comment">//用来安装我们需要的库， 以及node的一些命令</span></span><br><span class="line">│   ├──tsconfig.json  <span class="comment">//用来配置typescript</span></span><br><span class="line">│   ├──style.css      <span class="comment">//这个playground的css</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Form_Component">Form Component</h2><p>在<a href="http://gabriel0402.github.io/2015/12/21/overview/">Angular2 初探</a>中介绍了app.component.ts里面的第一个component，下面要介绍的是关于表单的component。上篇博客介绍过了，angular2是一个完全模块化的框架，所以在这我也把整个form component模块化成一个，然后把它加入到app.component中。我定义的form component的selector是hero-form，所以app.component的代码如下：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@Component(&#123;</span></span><br><span class="line">    selector: 'my-app',</span><br><span class="line">    template:`</span><br><span class="line">    <span class="variable">&lt; hero &gt;</span><span class="variable">&lt; /hero &gt;</span></span><br><span class="line">    <span class="variable">&lt; hero-form &gt;</span><span class="variable">&lt;/ hero-form &gt;</span>   //加入 form component的模块</span><br><span class="line">    <span class="variable">&lt; heroes-list &gt;</span><span class="variable">&lt; /heroes-list &gt;</span></span><br><span class="line">    `,</span><br><span class="line">    directives:[HeroComponent, HeroFormComponent,HeroesListComponent]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>因为这是一个模块化的世界，所以如果我们想定义一个对象，比如一个英雄，我们要给他一个id，给他一个名字。在Angular2 里面，我们可以给他定义个一个interface，比如:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">interface</span> <span class="tag">Hero</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">id</span>:<span class="value"> number</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">name</span>:<span class="value"> string</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>因为是typescript，所以在使用的时候可以给变量定义type。比如我们要定义一群英雄，可以这么写：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var HEROES: Hero[] = [</span><br><span class="line">    &#123; <span class="string">"id"</span>: <span class="number">11</span>, <span class="string">"name"</span>: <span class="string">"Mr. Nice"</span> &#125;,</span><br><span class="line">    &#123; <span class="string">"id"</span>: <span class="number">12</span>, <span class="string">"name"</span>: <span class="string">"Narco"</span> &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure></p>
<p>在这里，HEROS就被加上了Hero的type。这是interface的一个用例。然而，当我们的英雄里面不仅仅是要定义type的时候，interface就不够用了，比如我们想定义一些属于英雄的方法，或者逻辑，熟悉ood的童鞋肯定想到了类。没错，在angular2里面你可以像在其他语言里面一样方便的写类了：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> Hero &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(</span><br><span class="line">    public id: number,</span><br><span class="line">    public name: string,</span><br><span class="line">    public power: string,</span><br><span class="line">    public alterEgo?: string</span><br><span class="line">  ) </span>&#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个类可以被angular2用来新建一个英雄的对象。和其他语言的类一样，这个类可以有一个constructor，来初始化一些参数。比如：<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myHero =  <span class="keyword">new</span> <span class="type">Hero</span>(<span class="number">42</span>, <span class="symbol">'SkyDog'</span>, <span class="symbol">'Fetch</span> any <span class="keyword">object</span> at any distance', <span class="symbol">'Leslie</span> <span class="type">Rollover'</span>);</span><br></pre></td></tr></table></figure></p>
<p>有一点要说明的是“alterEgo”后面有一个问号，这代表这个参数是可选的，在我们新建对象的时候这个参数可有可无。如果没有也不影响整个类的初始化。我们也可以加一些类的函数在里面完成一些功能。<br>对于这个form component，我会有一个有一个表单的html的模板以及form component来处理表单的验证。上一个博客说到我们可以在component的template里面直接加入html来渲染页面。但当要嵌入的html太长的时候，另外一个解决办法是把要渲染的html写入一个html文件中，然后用templateUrl来加入这个模板。具体如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span>(&#123;</span><br><span class="line">  <span class="attribute">selector</span>: <span class="string">'hero-form'</span>,</span><br><span class="line">  <span class="attribute">templateUrl</span>: <span class="string">'app/hero-form.component.html'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>然后这里是我们加入的模板：<a href="https://github.com/Gabriel0402/angular2_beta_test/blob/master/app/hero-form/hero-form.component.html" target="_blank" rel="external">hero-form.component.html</a>,我会逐个开始介绍。</p>
<p>首先，硬生生的form是不好看的，我们可以先加入bootstrap来让整个form变得好看一些：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> bootstrap <span class="comment">--save</span></span></span><br></pre></td></tr></table></figure></p>
<p>然后在index.html里面把css加入到head里面<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">href</span>=<span class="value">"node_modules/bootstrap/dist/css/bootstrap.min.css"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>由于这一章还没说到http的post request，所以就小hack一下用div的[ hidden ]属性来显示这个submit的过程。在这个模块里面定义个一个submitted的变量，初始值是true， 然后提交之前的表单信息在submitted为true的时候显示，提交之后的信息在submitted为false的时候显示。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="tag">div</span> [hidden]=<span class="string">"submitted"</span> &gt;(include <span class="tag">form</span> information)&lt; / <span class="tag">div</span> &gt;</span><br><span class="line">&lt; <span class="tag">div</span> [hidden]=<span class="string">"submitted"</span> &gt;(include information after submit)&lt; / <span class="tag">div</span> &gt;</span><br></pre></td></tr></table></figure></p>
<p>在上一章已经说过什么是双向绑定了，而这里也用到了[ ( ngModel ) ]来双向绑定form里面的input。同时我们也可以用*ngFor 来表示下拉框里面可以选择的选项，然后在模块中定义powers就可以有下拉框的选项了。<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt; <span class="attribute">select</span> <span class="attribute">class</span>=<span class="value">"form-control"</span> <span class="attribute">required</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt; <span class="attribute">option</span> *<span class="attribute">ngFor</span>=<span class="value">"#p of powers"</span> [<span class="attribute">value</span>]=<span class="value">"p"</span> &gt;</span></span><span class="expression">&#123;&#123;<span class="variable">p</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt; /<span class="attribute">option</span> &gt;</span></span><br><span class="line"><span class="tag">&lt; /<span class="attribute">select</span> &gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>这样一来，这个表单就做好了，但是在表单中我们想要有verification的信息。比如某个input box必须有内容，或者email的inputbox必须是email的格式，或者下拉框必须选择一个内容等等等等。 在没有angular2的时候，所有的信息会在你按提交按钮的时候进行验证看输入是否正确，然后会给提示哪个输入不正确。但是有了angular2之后，这一切都可以很简单的完成了。<br>在angular2中，我们使用ngControl来验证输入是否正确。ngControl 根据不同的状态来更新不同的状态，具体如表：<br>| 状态                | 如果为真          | 如果为假         |<br>| control被访问了      | ng-touched      | ng-untouched    |<br>| control的内容被改变了 | ng-dirty        | ng-pristine     |<br>| control的内容是有效的 | ng-valid        | ng-invalid      |<br>当我们要使用ngControl的时候只用给他定义个名字即可：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; input <span class="class"><span class="keyword">type</span>=</span><span class="string">"text"</span> <span class="class"><span class="keyword">class</span>=</span><span class="string">"form-control"</span> required</span><br><span class="line">  [(ngModel)]=<span class="string">"model.name"</span></span><br><span class="line">  ngControl=<span class="string">"name"</span> &gt;</span><br></pre></td></tr></table></figure></p>
<p>然后具体ngControl的状态如图所示：<br><img src="https://angular.io/resources/images/devguide/forms/control-state-transitions-anim.gif" alt="Aaron Swartz"></p>
<p>然后我们就可以给这些class定义css来给用户页面上的反馈:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">style</span><span class="class">.css</span></span><br><span class="line"><span class="class">.ng-valid</span><span class="attr_selector">[required]</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border-left</span>:<span class="value"> <span class="number">5px</span> solid <span class="hexcolor">#42A948</span></span></span>; <span class="comment">/* green */</span></span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class">.ng-invalid</span> <span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border-left</span>:<span class="value"> <span class="number">5px</span> solid <span class="hexcolor">#a94442</span></span></span>; <span class="comment">/* red */</span></span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>然而，如果我们想要再加一个错误信息到表单里面，我们不仅需要ng-valid这个class还需要一个本地模板来操作。具体如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt; input <span class="class"><span class="keyword">type</span>=</span><span class="string">"text"</span> <span class="class"><span class="keyword">class</span>=</span><span class="string">"form-control"</span> required</span><br><span class="line">  [(ngModel)]=<span class="string">"model.name"</span></span><br><span class="line">    ngControl=<span class="string">"name"</span>  #name=<span class="string">"ngForm"</span> &gt;</span><br><span class="line">&lt; div [hidden]=<span class="string">"name.valid"</span> <span class="class"><span class="keyword">class</span>=</span><span class="string">"alert alert-danger"</span> &gt;</span><br><span class="line">  <span class="type">Name</span> is required</span><br><span class="line">&lt; /div&gt;</span><br></pre></td></tr></table></figure></p>
<p>在这里，input通过ngModel双向绑定到model的name上，然后和ngFor里面的本地模板一样，对于ngForm我们也要有个本地模板，当我们设定 #name=”ngForm” 的时候，angular2识别了这个语法然后把这个name作为ngControl的一个实例，所以在另外一个没有ngControl的div中我们可以使用name.valid来观察这个状态是否有效，然后选择相应的css。<br>做完这些input之后就需要做提交功能了。在提交的时候由于上面每个输入框或者选择框都会有是否有效的信息，然后在最后提交的时候需要综合考虑整个表单是否有效。所以要这么做:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; form <span class="list">(<span class="keyword">ngSubmit</span>)</span>=<span class="string">"onSubmit()"</span> #heroForm=<span class="string">"ngForm"</span> &gt;</span><br></pre></td></tr></table></figure></p>
<p>首先在建立表单的时候定义一个 #heroForm作为ngForm这个directive的钥匙，当我们设置了这个本地模板之后，这个heroForm就可以接触整个form，然后看是否每个在表单里面的元素都有效。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt; button <span class="class"><span class="keyword">type</span>=</span><span class="string">"submit"</span> <span class="class"><span class="keyword">class</span>=</span><span class="string">"btn btn-default"</span></span><br><span class="line">        [disabled]=<span class="string">"!heroForm.form.valid"</span>&gt;<span class="type">Submit</span>&lt; /button &gt;</span><br></pre></td></tr></table></figure></p>
<p>这样做了之后通过 (heroForm.form.valid)来看是否表单里面所有的元素都有效，如果都有效则让提交按钮可以提交，否则就让提交键变暗不能提交。</p>
<h2 id="小结">小结</h2><p>Angular2 让表单验证变得实时有效。用户可以在输入表单信息的时候就验证输入的信息是否有效，通过css来给用户以反馈，同时也可以通过整张表单是否有效来决定用户是否能够提交。这样一来一方面表单验证可以完全在前端实现，减轻了后端的负担，另一方面在前端给用户实时的输入反馈，增加了表单的能动性。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>这是Angular2教程的第二部分，主要介绍Angular2的form的使用。相关博客如下：</p>
<ol>
<li><a href="http://gabriel0402.github.io/2015/12/21/overview/">Angular2 初探</a></li>
<li>Angular2 dependency injection</li>
<li>Angular2之rxjs以及http的世界</li>
<li>Angular2 cheatsheet</li>
</ol>]]>
    
    </summary>
    
      <category term="Angular2" scheme="http://gabriel0402.github.io/tags/Angular2/"/>
    
      <category term="Angular2 教程" scheme="http://gabriel0402.github.io/tags/Angular2-%E6%95%99%E7%A8%8B/"/>
    
      <category term="form" scheme="http://gabriel0402.github.io/tags/form/"/>
    
      <category term="Angular2" scheme="http://gabriel0402.github.io/categories/Angular2/"/>
    
      <category term="form" scheme="http://gabriel0402.github.io/categories/Angular2/form/"/>
    
      <category term="Angular2 教程" scheme="http://gabriel0402.github.io/categories/Angular2/form/Angular2-%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Angular2 初探]]></title>
    <link href="http://gabriel0402.github.io/2015/12/21/overview/"/>
    <id>http://gabriel0402.github.io/2015/12/21/overview/</id>
    <published>2015-12-22T07:30:27.000Z</published>
    <updated>2015-12-26T04:39:44.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Angular2初探">Angular2初探</h2><p>盼星星盼月亮终于把angular2 beta盼来了，在beta前一个月快一天一个release都把小G折磨坏了，小G公司用的angular2，然后就跟着Google那些工程师一天一个update，然后还要看update把以前的啥功能break了没，当时改rxjs的api的时候真的是想死的心都有了。还有rxjs带来的各种bug，终于迎来了angular2 beta，码农翻身做主人，真是这个月最开心的事情了。接下来就是把所有code改好build pass就好。小G用angular已经两年多了，一开始用的angular做了一个officeapp，公司看不错就migrate到angular2的webapp，所以小G是经历过angular1和angular2的人，看过angular1的各种丑和angular2的各种帅。所以这篇文章主要是强推angular2的软文，主要快速上手angular2，介绍一下angular2的主要优势，快速接触angular2的一些语法及Component，Service的用法。还有就是介绍小G最喜欢的rxjs，因为angular2已经基于rxjs了，把所有东西变成stream然后各种神操作。当然一篇blog不足够介绍这么多，所以小G会分以下几块：</p>
<ol>
<li>本篇blog会初步介绍angular2的一些简单语法及快速上手。</li>
<li>下一篇blog会介绍angular form 的用法</li>
<li>再下一篇blog会介绍angular2里面的dependency injection的主要用法以及用ood的方法来做dom manipulation。</li>
<li>下下篇最重要会介绍小G最爱的rxjs。</li>
<li>小G还会写个cheatsheet，关于angular2的主要用法以及rxjs的主要用法。rxjs的主要用法按decision tree的方法展示。<a id="more"></a>
</li>
</ol>
<h2 id="参考资料">参考资料</h2><p>我是第一次见有公司能把framework的文档写的这么好的，google真是给了我惊喜。如果大家不想从头开始写，小G我写了个简单app，囊括了google angular2文档里的tutorial。这里上链接：<br><a href="https://github.com/Gabriel0402/angular2_beta_test" target="_blank" rel="external">Angular 2 quick start</a>. 所以这个app的文件结构是这样的：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">├──angular2/                                    </span><br><span class="line">│   │</span><br><span class="line">│   ├──<span class="keyword">app</span>/                               </span><br><span class="line">│   │   ├──<span class="keyword">boot</span>.ts                          </span><br><span class="line">│   │   ├──<span class="keyword">app</span>.component.ts   </span><br><span class="line">│   │   ├──hero/                  <span class="comment">//这篇博客用   </span></span><br><span class="line">│   │   |   |──hero.component.ts</span><br><span class="line">│   │   ├──hero-<span class="keyword">form</span>/             <span class="comment">//form blog 用</span></span><br><span class="line">│   │   |   ├──hero.ts                         </span><br><span class="line">│   │   |   |──hero-<span class="keyword">form</span>.component.ts</span><br><span class="line">│   │   |   |──hero-<span class="keyword">form</span>.component.html</span><br><span class="line">│   │   ├──hero-<span class="keyword">list</span>/             <span class="comment">//dependency injection 用</span></span><br><span class="line">│   │   |   ├──...</span><br><span class="line">│   ├──index.html</span><br><span class="line">│   ├──package.json   <span class="comment">//用来安装我们需要的库， 以及node的一些命令</span></span><br><span class="line">│   ├──tsconfig.json  <span class="comment">//用来配置typescript</span></span><br><span class="line">│   ├──style.css      <span class="comment">//这个playground的css</span></span><br></pre></td></tr></table></figure>
<h2 id="文件构成">文件构成</h2><h3 id="package-json">package.json</h3><p>用过前端的都知道，npm拯救了世界。所以我们用angular2的时候肯定也会用上npm来帮我们加各种库。所以对node或者npm熟悉的肯定也知道package.json。 在package.json里面，你可以定义script：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"tsc"</span>: <span class="string">"tsc"</span>,</span><br><span class="line">    <span class="string">"tsc:w"</span>: <span class="string">"tsc -w"</span>,</span><br><span class="line">    <span class="string">"lite"</span>: <span class="string">"lite-server"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"concurrent \"</span>npm <span class="built_in">run</span> tsc:w\<span class="string">" \"</span>npm <span class="built_in">run</span> lite\<span class="string">" "</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></p>
<p>在这里你可以设置你一会要用npm跑的命令，以这个为例，如果你跑npm start，那他就会先跑npm run tsc用tsc compile typescript到javascript，然后跑npm run lite跑server来host整个app。<br>还有dependencies和devdepdencies，你可以在里面加你想要使用的库，这样你就可以用npm install安装你所有想要的库。这里有个小trick，如果你想把这个库装到系统里面，就要跑<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> [<span class="keyword">test</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>如果你只想随便使用一下，就跑：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> [<span class="keyword">test</span>]</span></span><br></pre></td></tr></table></figure></p>
<p>如果你不仅想用还想加到packge.json里面，那就要使用<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> <span class="comment">--save [test]</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="typescript-json">typescript.json</h3><p>这个文件主要用来配置typescript的compiler，比如用啥target，用啥module，是不是要设置sourcemap，是不是要要设输出路径什么的。小G在这里配置一个输出dist，这样生成的js和map就不会和tsfile合在一起，他们会到一个单独的文件夹，<br>然后index.html会去查找。</p>
<h3 id="index-html">index.html</h3><p>这个是整个app存在的html支持，angular2说白了还是javascript，它是不能脱离html的存在。所以跟普通的javascript一样，需要html来load这个框架。在这个例子中小G就使用了systemjs，这个库能找到angular2 的入口然后把整个app load出来。<br>当然不仅仅可以使用systemjs，还有一些其他的框架比如webpack，可以bundle你的库让你的库不再成为一团乱麻。不过代价是他会有个很奇怪的build 方式，他有个server来查看你的code的改变然后在memory里面compile typescript然后把编译好的javascript放到memory里面然后用webpack dev server host然后让index.html直接找，这样的坏处是在debug的时候sourcemap很难找。虽然chrome debugger可以很容易解决这个问题。但是其他编译器比如vscode的chrome debugger extension就没有那么智能了。小G曾经尝试用vscode debug angular webpack starter，过程非常痛苦。</p>
<h3 id="boot">boot</h3><p>Angular2 对于angular1一个最大的进步是所有的东西都模块化了，web component好像变成了现在web technology的一个趋势。比如google正在推崇的polymer就完全使用了web component的思想，他给你很多个component，就像搭积木一样把你要的component下载下来，然后搭起来搭成你想要的一个web app。小G觉得这个想法是很不错，不过小G试了下polymer反应还是有点慢，虽然那些component做的很好看很material design，但是用户体验太慢的话还是不行吧。但是我相信polymer一直在进步，总有一天可以很好的使用它。这个boot等于整个app的入口，在boot.ts里面加入了这个app的root component，然后在index里面用systemjs调用这个boot，就把这个app整个load起来了。具体如下：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index.html</span><br><span class="line">    |</span><br><span class="line">    |systemjs调用<span class="keyword">boot</span></span><br><span class="line">  <span class="keyword">boot</span></span><br><span class="line">    |<span class="keyword">boot</span>调用模块化<span class="keyword">app</span>的root component</span><br><span class="line">    |</span><br><span class="line">  <span class="keyword">app</span></span><br></pre></td></tr></table></figure></p>
<p>而boot在调用模块化的component root的时候使用了bootstrap()的函数，我们可以importanglar2/core来得到bootstrap（）这个函数。看到这里大家可能要想为啥不直接用index load app 为啥要通过一个boot呢？确实如果只想做web app，可以直接用systemjs来load app。有boot的原因是因为我们可能不仅仅想做web application，<br>我们还想做native app， 还想做cordova或者ionic的app，这样只需要替换boot其他所有的代码都可以复用，这是angular2的一个很大的改善。angular1里面并没有很好的支持这一个功能。</p>
<h3 id="app">app</h3><p>正如小G刚才所说，angular2把所有的组建都模块化了，在angular2里面，你的整个app可以变成很多个模块，这些模块可以定义输入输出，也可以继承，可以拼接，这些模块就是不同的component，component之间的通信，数据交换就用service。在小G写的例子里，可以看到就加入了三个模块：hero，hero-form，heros-list。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">@Component(&#123;</span></span><br><span class="line">    selector: 'my-app',</span><br><span class="line">    template:`</span><br><span class="line">    <span class="variable">&lt; hero&gt;</span><span class="variable">&lt; /hero&gt;</span></span><br><span class="line">    <span class="variable">&lt; hero-form&gt;</span><span class="variable">&lt; /hero-form&gt;</span></span><br><span class="line">    <span class="variable">&lt; heroes-list&gt;</span><span class="variable">&lt; /heroes-list&gt;</span></span><br><span class="line">    `,</span><br><span class="line">    directives:[HeroComponent, HeroFormComponent,HeroesListComponent]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>首先@Component是angular2里面新引进的函数，通过这个函数我们可以设置selector，template，directives，styles等等。当然如果你要使用Component这个函数就要引入库：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">'angular2/core'</span>;</span><br></pre></td></tr></table></figure></p>
<p>当然还可以引入子模块，用相对路径即可：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;HeroComponent&#125; <span class="keyword">from</span> <span class="string">'./hero/hero.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HeroFormComponent&#125; <span class="keyword">from</span> <span class="string">'./hero-form/hero-form.component'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;HeroesListComponent&#125; <span class="keyword">from</span> <span class="string">'./hero-list/heroes-list.component'</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="selector">selector</h4><p>主要用来定义外部的模块如何使用这个模块。比如在app.component中selector是my-app，那在外部的index.html里面要load app.component这个模块就要使用<my-app></my-app></p>
<h4 id="template">template</h4><p>主要用来定义这个模块里面的html结构，他也可以加入内部的模块，比如这个app.component就加入了三个不同的子模块。这样写html是不是好像就像搭积木一样简单了？有一点要注意的是当template引用html的时候需要使用‘`’符号，一般这个符号在键盘上数字键1的左边。<br>在template里还有一个很重要的概念，用过angular1的童鞋都知道怎么在html里面引用controller里面的变量，没错，用{ { } }，在angular2里面也一样。 我们在class里面定义了一个变量，在template里面就可以用{ { } }直接引用。例如：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">	selector:<span class="string">'hero'</span>,</span><br><span class="line">    template: `</span><br><span class="line">          &lt; <span class="keyword">div</span> &gt;&#123;&#123;title&#125;&#125;&lt; /<span class="keyword">div</span> &gt;</span><br><span class="line">       `</span><br><span class="line">&#125;)</span><br><span class="line">export <span class="class"><span class="keyword">class</span> <span class="title">HeroComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> title = <span class="string">'Tour of Heroes'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样可以在template直接引用class里面的title，等于template里面是&lt; div&gt;Tour of Heroes&lt; /div&gt;</p>
<p>然后你就可以随意改这个变量，然后render出来的html也会跟着改变。<br>另外我在template里面想提到的是@Input @Output factory method以及[(ngModel)]的双向绑定。</p>
<h5 id="@Input">@Input</h5><p>这个@Input是用来定义模块的输入的，用来让父模块往子模块传递内容：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Component</span>(&#123;</span><br><span class="line">  <span class="attribute">selector</span>: <span class="string">'bank-account'</span>,</span><br><span class="line">  <span class="attribute">template</span>: <span class="built_in">`</span><br><span class="line">    Bank Name: &#123;&#123;bankName&#125;&#125;</span><br><span class="line">    Account Id: &#123;&#123;id&#125;&#125;</span><br><span class="line">  `</span></span><br><span class="line">&#125;)</span><br><span class="line">class BankAccount &#123;</span><br><span class="line">  <span class="variable">@Input</span>() <span class="attribute">bankName</span>: string;</span><br><span class="line">  <span class="variable">@Input</span>(<span class="string">'account-id'</span>) <span class="attribute">id</span>: string;</span><br><span class="line">  <span class="comment">// this property is not bound, and won't be automatically updated by Angular</span></span><br><span class="line">  <span class="attribute">normalizedBankName</span>: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@Component</span>(&#123;</span><br><span class="line">  <span class="attribute">selector</span>: <span class="string">'app'</span>,</span><br><span class="line">  <span class="attribute">template</span>: <span class="built_in">`</span><br><span class="line">     &lt; bank-account bank-name="RBC" account-id="4747"&gt;&lt; bank-account&gt;</span><br><span class="line">  `</span>,</span><br><span class="line">  <span class="attribute">directives</span>: [BankAccount]</span><br><span class="line">&#125;)</span><br><span class="line">class App &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>再这个例子中，父模块是app，子模块是BankAccount， 在app中我们想往子模块里面传递back-name和account-id这两个信息，可以通过property的方式最简单直接，而子模块要接受这个property就要用@Input来接收。子模块会在BankAccount里面直接接收传递过来的property。传递的方式可以是驼峰法，也可以直接写在input里面，就如<br>例子里面写的那样。要记住一点的是父模块在引用子模块的时候是用的[]。</p>
<h5 id="@Output">@Output</h5><p>如果我们的子模块想自定义一些event传递给父模块又该怎么做呢？这时候就要用到@Output了。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="property">@Directive</span>(&#123;</span><br><span class="line">  <span class="attribute">selector</span>: <span class="string">'interval-dir'</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntervalDir</span> &#123;</span></span><br><span class="line">  <span class="property">@Output</span>() everySecond = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">  <span class="property">@Output</span>(<span class="string">'everyFiveSeconds'</span>) five5Secs = <span class="keyword">new</span> EventEmitter();</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.everySecond.emit(<span class="string">"event"</span>), <span class="number">1000</span>);</span><br><span class="line">    setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.five5Secs.emit(<span class="string">"event"</span>), <span class="number">5000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="property">@Component</span>(&#123;</span><br><span class="line">  <span class="attribute">selector</span>: <span class="string">'app'</span>,</span><br><span class="line">  <span class="attribute">template</span>: `<span class="javascript"></span><br><span class="line">    &lt; interval-dir (every-second)=<span class="string">"everySecond()"</span> (every-five-seconds)=<span class="string">"everyFiveSeconds()"</span>&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt; /<span class="attribute">interval-dir</span>&gt;</span></span><br><span class="line">  </span></span>`,</span><br><span class="line">  <span class="attribute">directives</span>: [IntervalDir]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> &#123;</span></span><br><span class="line">  everySecond() &#123; <span class="built_in">console</span>.log(<span class="string">'second'</span>); &#125;</span><br><span class="line">  everyFiveSeconds() &#123; <span class="built_in">console</span>.log(<span class="string">'five seconds'</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为在普通的html里面，比如button我们会有onclick这种event来监听这个button是否被按了，然后angular2也完全允许我们自定义这种event listening的模式，我们可以给任何模块定义这种event，当触发了event之后就会从子模块往父模块传递子模块的信息。</p>
<p>再这个例子里，父模块是app，子模块是IntervalDir， 然后在子模块定义event触发的条件，比如每隔1s要触发事件，每隔5s要触发事件。然后当父模块监听到这些事件时可以做相应的操作。当然我们如果想传递信息，可以在new EventEmitter()里面加入我们想要传递的东西，然后在使用的时候加入函数的参数里面。比如我们想传递一个<br>test，我们只需要这么改：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">IntervalDir</span> &#123;</span><br><span class="line">  @<span class="type">Output</span><span class="container">()</span> everySecond = new <span class="type">EventEmitter</span><span class="container">(<span class="title">test</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt; interval-dir <span class="container">(<span class="title">every</span>-<span class="title">second</span>)</span>="everySecond<span class="container">(<span class="title">test</span>)</span>" <span class="container">(<span class="title">every</span>-<span class="title">five</span>-<span class="title">seconds</span>)</span>="everyFiveSeconds<span class="container">()</span>"&gt;</span><br><span class="line">everySecond<span class="container">(<span class="title">test</span>)</span> &#123; console.log<span class="container">(<span class="title">test</span>)</span>; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>而在这里，父模块在引用子模块的时候是用的()。</p>
<h5 id="[(ngModel)]">[(ngModel)]</h5><p>最后当然是最经典的angular特有的ngModel双向binding了。而这个特性是&lt; input &gt;特有的。我们注意到了 [(ngModel)] 既有[]也有()。没错它既有Input的特性也有Output的特性。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="tag">input</span> [(ngModel)]=<span class="string">"hero.name"</span> placeholder=<span class="string">"name"</span> &gt;</span><br></pre></td></tr></table></figure></p>
<p>在这里，我们在view里面改input里面的内容，hero.name也会跟着改变，而如果我们在class里面改变hero.name在view里面的内容也会跟着改变。然后就是mvvm的世界了。</p>
<h4 id="directives">directives</h4><p>主要是加入子模块的模块，当我们定义了一个模块之后，如果我们想要它被别的模块使用，必须定义一个出口被别的模块使用，比如app.component这个模块最后就要：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>让angular2知道它是一个AppComponent模块，然后在boot里面可以加入这个模块。同理我也export了HeroComponent，HeroFormComponent以及HeroesListComponent模块。然后在app.component的一开始就import进来，然后就要在directive加入这些模块然后在template才能识别相应的selector。如果<br>不在directive中引入相应的模块，那在compile的时候template就不知道相应的selector是啥就不能正常的render了。</p>
<h4 id="providers">providers</h4><p>这个主要用来加入service的模块。当我们想在模块之中使用service的时候，和directive相同的道理，我们需要加入provider这样这个模块就知道使用的service的provider。小G在用angular的过程中碰到最多的问题就是missing provider的问题，在angular1中可能是由于service的dependency之间有loop，<br>表示service互相依赖，会有问题。但angular2由于模块化了这个dependency injection的问题得到了很好的解决。如果再碰到这类问题首先要检查模块是否加入了service provider。</p>
<h4 id="styles">styles</h4><p>这个主要定义这个模块使用的css，不用放到外部的style.css里面。这样这个模块的css完全由自己掌控，是不是方便了很多？</p>
<p>这整个app的root component介绍完了，这个root component主要功能是加载了其他模块。这个博客还会介绍一个hero component。</p>
<h3 id="hero_component">hero component</h3><p>这块主要介绍的就是template里面的input和output还有ngFor:<br><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt; <span class="attribute">li</span> *<span class="attribute">ngFor</span>=<span class="value">"#hero of heroes"</span> </span><br><span class="line">    [<span class="attribute">class.selected</span>]=<span class="value">"hero === selectedHero"</span></span><br><span class="line">    (<span class="attribute">click</span>)=<span class="value">"onSelect(hero)"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt; <span class="attribute">span</span> <span class="attribute">class</span>=<span class="value">"badge"</span>&gt;</span></span><span class="expression">&#123;&#123;<span class="variable">hero.id</span>&#125;&#125;</span><span class="xml"><span class="tag">&lt; /<span class="attribute">span</span>&gt;</span> </span><span class="expression">&#123;&#123;<span class="variable">hero.name</span>&#125;&#125;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt; /<span class="attribute">li</span> &gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>比如我们有一个list的heros，我们可以在html里面用ngFor来循环这个list然后把list里面的英雄输出到html里面。在这里的语法和angular1完全不一样了。在angular1里面，完全没有<em>以及#的符号，但是在angular2里面，</em>和#确实很关键的语法。<br>( <em> )这个在ngFor的前缀表示整个&lt; li &gt;元素以及它的子元素合成一个master模板。如果不想使用( </em> ),ngFor需要被包含在一个template的元素里面：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attribute">template</span> <span class="attribute">ngFor</span> #<span class="attribute">hero</span> [<span class="attribute">ngForOf</span>]=<span class="value">"heroes"</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt; <span class="attribute">hero-detail</span> [<span class="attribute">hero</span>]=<span class="value">"hero"</span> &gt;</span><span class="tag">&lt; /<span class="attribute">hero-detail</span> &gt;</span></span><br><span class="line"><span class="tag">&lt; /<span class="attribute">template</span> &gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Angular2还有这个语法的就是<em>ngIf。如果不用(</em>)也需要把ngIf包含在template里面。<br>而在hero前面的( # )表示了hero是一个本地模板变量，整个合起来就是循环heros的list，然后对于每个hero，在&lt; li &gt;&lt; /li &gt;内可以进行操作。<br>从上面的例子还可以看到input和output。只不过这两个都已经在li模块里面集成好了，不需要自己定义。所以对于li这个元素的input，我们可以定义这个li的class的是否被选择。对于li元素的output我们可以定义点击事件监听。然后在这个模块中进行相应的函数操作。</p>
<h2 id="小结">小结</h2><p>洋洋洒洒这么多，其实angular2的主要知识点有下面几个：</p>
<ol>
<li>Angular2的文件结构，typescript的设置，package.json的设置。</li>
<li>boot的作用，更换boot可以达到复用代码让代码工作在其他framework的作用。</li>
<li>Angular2是模块化的，自上而下的一个树状结构。每个模块之间可以互相调用，也可以用service互相通信。</li>
<li>Angular2里面的一些概念，比如Component，Directive，Provider，selector,template, @Input, @Output, [ ( ngModel) ], ngFor, ngIf.</li>
</ol>
<p>如果你知道上面这些是咋回事，那差不多可以开始自己写个angular2的app啦。一方面可以在小G的简单app上随便操作看效果，另一方面小G也给个angular2的快速开发app的project：<a href="https://github.com/AngularClass/angular2-webpack-starter" target="_blank" rel="external">angular2-webpack-starter</a>。小G就是用这个来做比较大型的app开发的。这个项目是跟着angular2不断在更新的，比较伤感的是用vscode很难debug。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Angular2初探">Angular2初探</h2><p>盼星星盼月亮终于把angular2 beta盼来了，在beta前一个月快一天一个release都把小G折磨坏了，小G公司用的angular2，然后就跟着Google那些工程师一天一个update，然后还要看update把以前的啥功能break了没，当时改rxjs的api的时候真的是想死的心都有了。还有rxjs带来的各种bug，终于迎来了angular2 beta，码农翻身做主人，真是这个月最开心的事情了。接下来就是把所有code改好build pass就好。小G用angular已经两年多了，一开始用的angular做了一个officeapp，公司看不错就migrate到angular2的webapp，所以小G是经历过angular1和angular2的人，看过angular1的各种丑和angular2的各种帅。所以这篇文章主要是强推angular2的软文，主要快速上手angular2，介绍一下angular2的主要优势，快速接触angular2的一些语法及Component，Service的用法。还有就是介绍小G最喜欢的rxjs，因为angular2已经基于rxjs了，把所有东西变成stream然后各种神操作。当然一篇blog不足够介绍这么多，所以小G会分以下几块：</p>
<ol>
<li>本篇blog会初步介绍angular2的一些简单语法及快速上手。</li>
<li>下一篇blog会介绍angular form 的用法</li>
<li>再下一篇blog会介绍angular2里面的dependency injection的主要用法以及用ood的方法来做dom manipulation。</li>
<li>下下篇最重要会介绍小G最爱的rxjs。</li>
<li>小G还会写个cheatsheet，关于angular2的主要用法以及rxjs的主要用法。rxjs的主要用法按decision tree的方法展示。]]>
    
    </summary>
    
      <category term="Angular2" scheme="http://gabriel0402.github.io/tags/Angular2/"/>
    
      <category term="Angular2 教程" scheme="http://gabriel0402.github.io/tags/Angular2-%E6%95%99%E7%A8%8B/"/>
    
      <category term="Angular2" scheme="http://gabriel0402.github.io/categories/Angular2/"/>
    
      <category term="Angular2 教程" scheme="http://gabriel0402.github.io/categories/Angular2/Angular2-%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客框架选择以及发布博客]]></title>
    <link href="http://gabriel0402.github.io/2015/12/13/blog/"/>
    <id>http://gabriel0402.github.io/2015/12/13/blog/</id>
    <published>2015-12-13T22:04:27.000Z</published>
    <updated>2015-12-14T01:09:32.000Z</updated>
    <content type="html"><![CDATA[<h2 id="框架选择">框架选择</h2><p>随着web技术的不断发展，可以产生静态博客的框架也越来越多，比如流行的<a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">jekyii</a>，<a href="http://octopress.org" target="_blank" rel="external">octopress</a>，<a href="https://hexo.io" target="_blank" rel="external">Hexo</a>，<a href="https://gohugo.io" target="_blank" rel="external">Hugo</a>，以及middleman，Pelican，Metalsmith。小G比较过集中常用的框架，比如github自带的jekyii，还有hugo。最后选择了Hexo。</p>
<ol>
<li>Github Pages默认使用jekyii作为建立静态博客的framework，但是对于jekyii，小G觉得一方面jekyii安装太过复杂，然后相对于其他的framework比较慢，所以就试了一下就没有再用了</li>
<li>Hugo听说轻量级以及速度很快，尝试了一下果然很快。然后跑去他的官网看文档，写的是很清楚。有一个问题是它的不同的theme有不用的configuration，所以在theme之间切换不是很容易，而且由于是轻量级的所以有很多东西需要自己配置，上手有点慢。</li>
<li>第一次用到hexo的时候觉得这个框架非常容易上手，一共就五个命令：hexo n, hexo clean, hexo g, hexo s, hexo d，从开发到配置到发布全部搞定。而且theme之间的切换也非常容易，而且大部分的configuration都已经集成，很容易使用。</li>
<li>这些做静态博客的framework都比较灵活，可以不费很多时间和精力从一个迁移到另一个，所以小G认为如果对这感兴趣可以把主流的framework都试一遍，找到自己最好的。小G本人觉得最好用的是hexo，所以决定使用这个framework。</li>
</ol>
<a id="more"></a>
<h2 id="发布博客">发布博客</h2><p>才开始写博客，所以小G打算使用gitpage来host这个静态的网站。</p>
<p><strong><em>建立github page 仓库</em></strong></p>
<p>在登录github后，新建一个仓库: [username].github.io。</p>
<p>这个仓库每个github账户只能建立一个，不过这是免费的，已经很不错了。</p>
<h3 id="Hexo安装">Hexo安装</h3><p>首先是安装hexo，你在电脑上需要安装nodejs和git。然后就可以安装hexo:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> hexo-cli</span></span><br></pre></td></tr></table></figure></p>
<p>安装完之后在command line 里面测试hexo是否安装好，直接输入hexo看是否会有如下信息:<br><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sage</span>: <span class="string">hexo &lt;command&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="livecodeserver">Commands:</span><br><span class="line">  clean     Removed generated <span class="built_in">files</span> <span class="operator">and</span> cache.</span><br><span class="line">  config    Get <span class="operator">or</span> <span class="built_in">set</span> configurations.</span><br><span class="line">  deploy    Deploy your website.</span><br><span class="line">  generate  Generate static <span class="built_in">files</span>.</span><br><span class="line">  help      Get help <span class="command"><span class="keyword">on</span> <span class="title">a</span> <span class="title">command</span>.</span></span><br><span class="line">  init      Create <span class="operator">a</span> <span class="built_in">new</span> Hexo <span class="built_in">folder</span>.</span><br><span class="line">  list      List <span class="operator">the</span> information <span class="operator">of</span> <span class="operator">the</span> site</span><br><span class="line">  migrate   Migrate your site <span class="built_in">from</span> other <span class="keyword">system</span> <span class="built_in">to</span> Hexo.</span><br><span class="line">  <span class="built_in">new</span>       Create <span class="operator">a</span> <span class="built_in">new</span> <span class="built_in">post</span>.</span><br><span class="line">  publish   Moves <span class="operator">a</span> draft <span class="built_in">post</span> <span class="built_in">from</span> <span class="title">_drafts</span> <span class="built_in">to</span> <span class="title">_posts</span> <span class="built_in">folder</span>.</span><br><span class="line">  render    Render <span class="built_in">files</span> <span class="operator">with</span> renderer plugins.</span><br><span class="line">  server    Start <span class="operator">the</span> server.</span><br><span class="line">  <span class="built_in">version</span>   Display <span class="built_in">version</span> information.</span><br><span class="line"></span><br><span class="line">Global Options:</span><br><span class="line">  <span class="comment">--config  Specify config file instead of using _config.yml</span></span><br><span class="line">  <span class="comment">--cwd     Specify the CWD</span></span><br><span class="line">  <span class="comment">--debug   Display all verbose messages in the terminal</span></span><br><span class="line">  <span class="comment">--draft   Display draft posts</span></span><br><span class="line">  <span class="comment">--safe    Disable all plugins and scripts</span></span><br><span class="line">  <span class="comment">--silent  Hide output on console</span></span><br><span class="line"></span><br><span class="line">For more help, you can use <span class="string">'hexo help [command]'</span> <span class="keyword">for</span> <span class="operator">the</span> <span class="keyword">detailed</span> information</span><br><span class="line"><span class="operator">or</span> you can check <span class="operator">the</span> docs: <span class="keyword">http</span>://hexo.io/docs/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Hexo配置">Hexo配置</h3><p>然后就是Hexo的配置了，首先是新建文件夹：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo init &lt;folder&gt;</span><br><span class="line"><span class="variable">$ </span>cd &lt;folder&gt;</span><br><span class="line"><span class="variable">$ </span>npm install</span><br></pre></td></tr></table></figure>
<p>然后文件夹里面的路径应该就如下所示：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line"><span class="string">|   ├── _drafts</span></span><br><span class="line"><span class="string">|   └── _posts</span></span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<ul>
<li>_config.yml：最重要的配置文件，你可以配置任何博客的参数，比如theme，背景什么的。具体可以看<a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">configuration</a>;</li>
<li>package.json: 大概了解nodejs的同学都知道，这个是node的安装包的配置文件;</li>
<li>source: 这里放了你所有要post的文档，支持markdown的格式;</li>
<li>theme: 你可以安装不同的theme到这个文件夹，等你要使用某个theme的时候在_config.yml里面配置就好。</li>
<li>scaffolds: Hexo根据scaffold来建立档案</li>
</ul>
<h3 id="新建博客">新建博客</h3><p>小G觉得要用hexo记住五个命令就好:<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> new “my blog”</span><br><span class="line"><span class="variable">$hexo</span> n <span class="string">"my blog"</span></span><br></pre></td></tr></table></figure></p>
<p>这个会新建一个post在source/_post文件夹下，是md的格式，你可以在里面写你要发布的内容。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> generate</span><br><span class="line"><span class="variable">$hexo</span> g</span><br></pre></td></tr></table></figure>
<p>这个会根据你的markdown以及配置生成静态文件，你可以deploy到github里面</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> serve</span><br><span class="line"><span class="variable">$hexo</span> s</span><br></pre></td></tr></table></figure>
<p>这个会在本地新建一个server host你刚刚生成的静态文件，你就可以在本地预览你的静态网站。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> deploy</span><br><span class="line"><span class="variable">$hexo</span> d</span><br></pre></td></tr></table></figure>
<p>这个会根据你的配置发布到你需要的host网站上。比如小G想把它发布到github page上，在_config.yml文件里就要配置deploy:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repository</span>: <span class="attribute">https</span>:<span class="comment">//github.com/Gabriel0402/gabriel0402.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>这样你都不用commit和push就可以自动发布到你的github page里面。是不是一键搞定？<br>当然如果你要deploy或者可以安装github desktop把你的计算机加入到github中，另一个方法是加sshkey，详见:<a href="http://www.jianshu.com/p/05289a4bc8b2" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></p>
<p>最后一个命令是clean，帮你clean cache然后发布，因为有时候hexo不能检测到你的内容的更改，所以你需要clean了cache之后再generate。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$hexo</span> clean</span><br></pre></td></tr></table></figure></p>
<p>通常小G还会写两个script直接自动化整个流程:</p>
<ol>
<li><p>写完一个post想在本地测试：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">s</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>写完一个post想直接发布：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">d</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>想要run这个script直接可以<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sh</span> <span class="keyword">run</span>.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<h3 id="在theme基础上建立自己的博客">在theme基础上建立自己的博客</h3><p>在试完这些功能之后我们可以尝试改变_config.yml的设置来选择我们自己的style。比如Yelee这个theme，当我们把它安装到theme文件夹下后，他自己也有_config.yml文件：</p>
<p>比如我们想改左边的导航栏，可以在header下改:<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Header</span></span><br><span class="line"><span class="attribute">menu</span>:</span><br><span class="line">  <span class="attribute">Homepage</span>: /</span><br><span class="line">  <span class="attribute">Archives</span>: <span class="regexp">/archives/</span></span><br><span class="line">  <span class="comment">#Tags: /tags/随笔</span></span><br><span class="line">  <span class="attribute">TagCloud</span>: <span class="regexp">/tags/</span></span><br><span class="line">  <span class="attribute">About</span>: <span class="regexp">/about/</span></span><br></pre></td></tr></table></figure></p>
<p>然后再这个文件里你可以改其他比如背景图片，头像图片，分享，这些在注释里都有标注。</p>
<p>Hexo的整个workflow很简单，值得一试。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="框架选择">框架选择</h2><p>随着web技术的不断发展，可以产生静态博客的框架也越来越多，比如流行的<a href="http://www.jianshu.com/p/05289a4bc8b2">jekyii</a>，<a href="http://octopress.org">octopress</a>，<a href="https://hexo.io">Hexo</a>，<a href="https://gohugo.io">Hugo</a>，以及middleman，Pelican，Metalsmith。小G比较过集中常用的框架，比如github自带的jekyii，还有hugo。最后选择了Hexo。</p>
<ol>
<li>Github Pages默认使用jekyii作为建立静态博客的framework，但是对于jekyii，小G觉得一方面jekyii安装太过复杂，然后相对于其他的framework比较慢，所以就试了一下就没有再用了</li>
<li>Hugo听说轻量级以及速度很快，尝试了一下果然很快。然后跑去他的官网看文档，写的是很清楚。有一个问题是它的不同的theme有不用的configuration，所以在theme之间切换不是很容易，而且由于是轻量级的所以有很多东西需要自己配置，上手有点慢。</li>
<li>第一次用到hexo的时候觉得这个框架非常容易上手，一共就五个命令：hexo n, hexo clean, hexo g, hexo s, hexo d，从开发到配置到发布全部搞定。而且theme之间的切换也非常容易，而且大部分的configuration都已经集成，很容易使用。</li>
<li>这些做静态博客的framework都比较灵活，可以不费很多时间和精力从一个迁移到另一个，所以小G认为如果对这感兴趣可以把主流的framework都试一遍，找到自己最好的。小G本人觉得最好用的是hexo，所以决定使用这个framework。</li>
</ol>]]>
    
    </summary>
    
      <category term="GitHub" scheme="http://gabriel0402.github.io/tags/GitHub/"/>
    
      <category term="Hexo" scheme="http://gabriel0402.github.io/tags/Hexo/"/>
    
      <category term="Markdown" scheme="http://gabriel0402.github.io/tags/Markdown/"/>
    
      <category term="blog相关" scheme="http://gabriel0402.github.io/categories/blog%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>
